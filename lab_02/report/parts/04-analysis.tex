\chapter{Аналитическая часть}
В данном разделе будут рассмотрены классический алгоритм умножениям матриц, алгоритм Винограда и его же оптимизированная версия.

\section{Матрица}
\textit{Матрицей} размером $m \times n$ называют прямоугольную числовую таблицу, состоящую из $m \cdot n$ чисел, которые расположены в $m$ строках и $n$ столбцах.
Состовляющие матрицу числа называют \textit{элементами} этой \textit{матрицы}~\cite{matrix}.

Матрицу обозначают
\begin{equation}
    \begin{pmatrix}
        a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
        a_{m1} & \vdots & \ddots & a_{mn}
        \end{pmatrix}.
\end{equation}

Над матрицами возможны следующие операции:
\begin{itemize}
    \item сложение матриц одинакового размера;
    \item произведение матрицы на число;
    \item произведение матриц, которое определено лишь в случае, когда количество \textit{столбцов} первого сомножителя равно количеству \textit{строк} второго~\cite{matrix}.
\end{itemize}

\section{Классический алгоритм}
Пусть даны \textit{матрица} $A = (a_{ij})$ \textit{типа} $m \times n$ и \textit{матрица} $B = (b_{ij})$ \textit{типа} $n \times p$.
\textit{Произведением матриц} $A$ и $B$ называют матрицу $C = (c_{ij})$ типа $m \times p$ c \textit{элементами}
\begin{equation}
    \label{eq:classic_1}
    c_{ij} = \sum_{k=1}^{n}a_{ik}b_{kj} \quad (i = \overline{1, m}, j = \overline{1, p}),
\end{equation}
которую обозначают $C = AB$.

Классический алгоритм реализует формулу \ref{eq:classic_1}.

\section{Алгоритм Винограда}
Одним из самых эффективных по времени алгоритмов умножения матриц является алгоритм Винограда, имеющий асимптотическую сложность $O(n^{2,3755})$~\cite{vinograd-haskell}.

Рассмотрим два вектора:
\begin{equation}
    U = (u_{1}, u_{2}, u_{3}, u_{4}),
\end{equation}
\begin{equation}
    V = (v_{1}, v_{2}, v_{3}, v_{4}).
\end{equation}
Их скалярное произведение равно:
\begin{equation}
    \label{eq:scalar_prod}
    U \times V = u_{1}v_{1} + u_{2}v_{2} + u_{3}v_{3} + u_{4}v_{4},
\end{equation}
что равносильно
\begin{equation}
    \label{eq:vinograd_1}
    U \times V = (u_{1} + v_{2})(u_{2} + v_{1}) + (u_{3} + v_{4})(u_{4} + v_{3}).
\end{equation}

Возьмем упомянутые раннее матрицы $A, B$ и $С$. Cкалярное произведение, по замыслу Винограда, \ref{eq:scalar_prod} можно свести к следующему выражению:
\begin{multline}
    \label{eq:vinograd_2}
    c_{ij} = \sum_{k = 1}^{n / 2}(a_{i,2k - 1} + b_{j, 2k})(a_{i,2k} + b_{j, 2k - 1}) - \\ - \sum_{k = 1}^{n / 2}a_{i,2k - 1}a_{i,2k} - \sum_{k = 1}^{n / 2}b_{2k - 1,j}b_{2k,j}.
\end{multline}
В целях экономии количества арифметических операций Виноград предложил находить второе и третье слагаемое в \ref{eq:vinograd_2} заранее для каждой строки матрицы $A$ и каждого столбца матрицы \textit{B}.

Так, единожды вычислив для \textit{i}-ой строки матрицы $A$ значение выражения $\sum_{k = 1}^{n / 2}a_{i,2k - 1}a_{i,2k}$, его можно использовать далее $n$ раз для нахождения элементов \textit{i}-ой строки матрицы $С$.  

Аналогично, единожды вычислив для \textit{j}-ой столбца матрицы $B$ значение выражения $\sum_{k = 1}^{n / 2}b_{2k - 1,j}b_{2k,j}$, его можно использовать далее $n$ раз для нахождения элементов \textit{j}-ой столбца матрицы $С$~\cite{vinograd-alg}.

Для примера, приведенного в формуле \ref{eq:vinograd_1}, в клаcсическом умножении производится четыре умножения и три сложения; в алоритме Винограда~--- шесть умножений и девять сложений~\cite{vinograd-alg}. Но, несмотря на увеличение количества операций, 
выражение в правой части можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы.
Это позволит выполнить лишь два умножения и пять сложений, складывая затем только лишь с двумя предварительно вычисленными суммами соседних элементов текущих строк и столбцов. Операция сложения выполняется быстрее, поэтому на практике алгоритм должен работать
быстрее классического алгоритма умножения матриц.

При условии нечетного размера матрицы необходимо дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда}
Для программной реализации алгоритма, рассмотренного в предыдущем пункте, можно выполнить следующие оптимизации:
\begin{enumerate}
    \item значение $n / 2$, используемое в качестве ограничения цикла подсчета предварительных данных, можно кэшировать;
    \item операция умножения на 2 эффективнее реализовать как побитовый сдвиш влево на 1;
    \item при условии существования операторов \texttt{+=, -=} в выбранном языке программирования, соответсвующие операции сложения и вычитания с присваиванием следует реализовывать с помощью данных операторов.
\end{enumerate}

\section*{Вывод}
В данном разделе были рассмотрены алгоритмы умножения матриц: классический, алгоритм Винограда. Также были рассмотрены оптимизации, которые можно учесть при програмной реализации алгоритма Винограда.

Основным отличием этих алгоритмов является наличие предварительных вичислений~--- как следствие, количество операций умножения и сложения также различно.