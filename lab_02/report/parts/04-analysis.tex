\chapter{Аналитическая часть}
В данном разделе будут рассмотрены классический алгоритм умножениям матриц, алгоритм Винограда и его же оптимизированная версия.

\section{Матрица}
\textit{Матрицей} размером $m \times n$ называют прямоугольную числовую таблицу, состоящую из $m \cdot n$ чисел, которые расположены в $m$ строках и $n$ столбцах.
Состовляющие матрицу числа называют \textit{элементами} этой \textit{матрицы}~\cite{matrix}.

Матрицу обозначают
\begin{equation}
    \begin{pmatrix}
        a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
        a_{m1} & \vdots & \ddots & a_{mn}
        \end{pmatrix}.
\end{equation}

Над матрицами возможны следующие операции:
\begin{itemize}
    \item сложение матриц одинакового размера;
    \item умножение матрицы на число;
    \item умножение матриц, которое определено лишь в случае, когда количество \textit{столбцов} первого сомножителя равно количеству \textit{строк} второго~\cite{matrix}.
\end{itemize}

\section{Классический алгоритм}
Пусть даны \textit{матрица} $A = (a_{ij})$ \textit{типа} $m \times n$ и \textit{матрица} $B = (b_{ij})$ \textit{типа} $n \times p$.
\textit{Произведением матриц} $A$ и $B$ называют матрицу $C = (c_{ij})$ типа $m \times p$ c \textit{элементами}
\begin{equation}
    \label{eq:classic_1}
    c_{ij} = \sum_{k=1}^{n}a_{ik}b_{kj} \quad (i = \overline{1, m}, j = \overline{1, p}),
\end{equation}
которую обозначают $C = AB$.

Классический алгоритм реализует формулу \ref{eq:classic_1}.

\section{Алгоритм Винограда}
Одним из самых эффективных по времени алгоритмов умножения матриц является алгоритм Винограда, имеющий асимптотическую сложность $O(n^{2,3755})$~\cite{vinograd-haskell}.

Рассмотрим два вектора:
\begin{equation}
    U = (u_{1}, u_{2}, u_{3}, u_{4}),
\end{equation}
\begin{equation}
    V = (v_{1}, v_{2}, v_{3}, v_{4}).
\end{equation}
Их скалярное произведение равно:
\begin{equation}
    \label{eq:scalar_prod}
    U \times V = u_{1}v_{1} + u_{2}v_{2} + u_{3}v_{3} + u_{4}v_{4},
\end{equation}
что равносильно
\begin{equation}
    \label{eq:vinograd_1}
    U \times V = (u_{1} + v_{2})(u_{2} + v_{1}) + (u_{3} + v_{4})(u_{4} + v_{3}).
\end{equation}

Для упомянутых раннее матриц $A, B$ и $C$ скалярное произведение, по замыслу Винограда, \ref{eq:scalar_prod} можно свести к следующему выражению:
\begin{multline}
    \label{eq:vinograd_2}
    c_{ij} = \sum_{k = 1}^{n / 2}(a_{i,2k - 1} + b_{j, 2k})(a_{i,2k} + b_{j, 2k - 1}) - \\ - \sum_{k = 1}^{n / 2}a_{i,2k - 1}a_{i,2k} - \sum_{k = 1}^{n / 2}b_{2k - 1,j}b_{2k,j}.
\end{multline}
В целях экономии количества арифметических операций Виноград предложил находить второе и третье слагаемое в \ref{eq:vinograd_2} заранее для каждой строки матрицы $A$ и каждого столбца матрицы \textit{B}.

Так, единожды вычислив для \textit{i}-ой строки матрицы $A$ значение выражения $\sum_{k = 1}^{n / 2}a_{i,2k - 1}a_{i,2k}$, его можно использовать далее $n$ раз для нахождения элементов \textit{i}-ой строки матрицы $C$.  

Аналогично, единожды вычислив для \textit{j}-ой столбца матрицы $B$ значение выражения $\sum_{k = 1}^{n / 2}b_{2k - 1,j}b_{2k,j}$, его можно использовать далее $n$ раз для нахождения элементов \textit{j}-ой столбца матрицы $C$.

Для примера, приведенного в формуле \ref{eq:vinograd_1}, в клаcсическом умножении производится четыре умножения и три сложения; в алоритме Винограда~--- шесть умножений и девять сложений. Но, несмотря на увеличение количества операций, выражение в правой части можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы.
Это позволит выполнить лишь два умножения и пять сложений, складывая затем только лишь с двумя предварительно вычисленными суммами соседних элементов текущих строк и столбцов. Операция сложения выполняется быстрее, поэтому на практике алгоритм должен работать быстрее классического алгоритма умножения матриц~\cite{vinograd-alg}.

При условии нечетного размера матрицы необходимо дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\section{Оптимизированный алгоритм Винограда}
Для программной реализации алгоритма, рассмотренного в предыдущем пункте, можно выполнить следующие оптимизации:
\begin{enumerate}
    \item значение $n / 2$, используемое в качестве ограничения цикла подсчета предварительных данных, можно кешировать;
    \item операцию умножения на 2 эффективнее реализовать как побитовый сдвиг влево на 1;
    \item при условии существования операторов \texttt{+=, -=} в выбранном языке программирования, соответсвующие операции сложения и вычитания с присваиванием следует реализовывать с помощью данных операторов.
\end{enumerate}

\section{Алгоритм Штрассена}
Произведение $C$ двух матриц $A$ и $B$ размером $2 \times 2$ можно вычислить с помощью только \textbf{7}, а не \textbf{8} умножений, которые необходимы при использовании стандартного алгоритма.
Действие осуществляются с использованием следующих формул:
\begin{equation}
    \label{eq:strassen_1}
    \begin{gathered}
        \begin{pmatrix}
            c_{11} & c_{12} \\
            c_{21} & c_{22} 
        \end{pmatrix}
        = 
        \begin{pmatrix}
            a_{11} & a_{12} \\
            a_{21} & a_{22} 
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            b_{11} & b_{12} \\
            b_{21} & b_{22} 
        \end{pmatrix}
        = \\ =
        \begin{pmatrix}
            m_{1} + m_{4} - m_{5} + m_{7} & m_{3} + m_{5} \\
            m_{2} + m_{4} &m_{1} + m_{3} - m_{2} + m_{6}
        \end{pmatrix},
    \end{gathered}
\end{equation}
где
\begin{equation}
    \begin{gathered}
        m_{1} = (a_{11} + a_{22}) \cdot (b_{11} + b_{22}), \\
        m_{2} = (a_{21} + a_{22}) \cdot b_{11}, \\
        m_{3} = (b_{12} - b_{22}) \cdot a_{11}, \\
        m_{4} = a_{22} \cdot (b_{21} - b_{11}), \\
        m_{5} = (a_{11} + a_{12}) \cdot b_{22}, \\
        m_{6} = (a_{21} - a_{11}) \cdot (b_{11} + b_{12}), \\
        m_{7} = (a_{12} - a_{22}) \cdot (b_{12} + b_{22}).
    \end{gathered}
\end{equation}

Пусть матриц $A$ и $B$ размером $n \times n$, где $n$~--- стпень двойки.
Матрицы $A$ и $B$ и их произведение $C$ можно разделить на 4 подматрицы размером $\frac{n}{2} \times \frac{n}{2}$ каждую следующим образом:
\begin{equation}
    \label{eq:strassen_2}
    \begin{gathered}
        \begin{pmatrix}
            С_{11} & С_{12} \\
            С_{21} & С_{22} 
        \end{pmatrix}
        = 
        \begin{pmatrix}
            A_{11} & A_{12} \\
            A_{21} & A_{22} 
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            B_{11} & B_{12} \\
            B_{21} & B_{22}. 
        \end{pmatrix}
    \end{gathered}
\end{equation}

Для получения корректного произведения эти подматрицы рассматривают как числа.
Алгоритм Штрассена состоит в том, что требуемые 7 произведений подматриц размером $\frac{n}{2} \times \frac{n}{2}$ вычисляются рекурсивно и использованием описанного метода~\cite{strassen}.

\section*{Вывод}
В данном разделе были рассмотрены алгоритмы умножения матриц: классический, алгоритм Винограда, алгоритм Штрассена. Также были рассмотрены оптимизации, которые можно учесть при програмной реализации алгоритма Винограда.

Основным отличием этих алгоритмов является наличие предварительных вичислений~--- как следствие, количество операций умножения и сложения также различно.